@using AIUI2025.Services
@inject MarketDataService MarketData
@inject IJSRuntime JS
@inject TickService TickService
@using System.Threading
@implements IDisposable

<canvas id="tickChart" hidden="hidden" width="800" height="400"></canvas>

<div id="chartContainer" style="height: 400px; min-width: 310px"></div>

<div class="mb-2">
    <button @onclick="ZoomIn">Zoom In</button>
    <button @onclick="ZoomOut">Zoom Out</button>
    <button @onclick="PanLeft">Pan Left</button>
    <button @onclick="PanRight">Pan Right</button>
    <button @onclick="ResetZoom">Reset Zoom</button>
</div>

<div class="mb-2">
    <span>Range: @windowStart.ToString("g") - @windowEnd.ToString("g")</span>
    <span style="margin-left:1em;">(@(windowEnd - windowStart))</span>
    @if (IsFollowingLatest)
    {
        <span style="color: green; font-weight: bold; margin-left: 1em;">(Following Live Data)</span>
    }
</div>

<div>@(isUpdating ? "Loading..." : "")</div>

@code {
    private List<PriceTick> ticks = new();
    private Timer? refreshTimer;
    private bool isFirstRender = true;

    // Track the current time window for the chart
    private DateTime windowStart;
    private DateTime windowEnd;

    // FIX: Add missing isUpdating field
    private bool isUpdating = false;

    // Store initial window for reset
    private DateTime initialWindowStart;
    private DateTime initialWindowEnd;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (isFirstRender)
        {
            isFirstRender = false;
            await InitializeWindowAsync();
            await RefreshChartAsync();
            refreshTimer = new Timer(_ =>
{
    InvokeAsync(async () =>
    {
        await RefreshChartAsync();
        StateHasChanged();
    });
}, null, TimeSpan.FromSeconds(60), TimeSpan.FromSeconds(60));
        }
    }

    private async Task InitializeWindowAsync()
    {
        var candles = await MarketData.GetLatestActiveWindowAsync();
        if (candles.Count > 0)
        {
            windowStart = candles[0].Time;
            windowEnd = candles[^1].Time;
            initialWindowStart = windowStart;
            initialWindowEnd = windowEnd;
        }
    }

    private async Task RefreshChartAsync()
    {
        Stat.WindowStart = windowStart;
        Stat.WindowEnd = windowEnd;

        var candles = await MarketData.GetCandlesAsync(windowStart, windowEnd);
        // Filter candles to current window
        var filteredCandles = candles.Where(c => c.Time >= windowStart && c.Time <= windowEnd).ToList();
        var signals = SignalService.ExtractSignals(candles, new StrategyConfig());

        var chartData = filteredCandles.Select(c => new object[]
        {
            DateTimeToUnix(c.Time),
            c.Open, c.High, c.Low, c.Close
        }).ToArray();

        var patternPoints = signals.Select(h => new
        {
            x = DateTimeToUnix(h.Time),
            y = filteredCandles.FirstOrDefault(c => c.Time == h.Time)?.Close ?? 0,
            label = h.Type,
            confidence = (int)(h.Confidence * 100)
        }).ToArray();

        await JS.InvokeVoidAsync("renderCandleChart", "chartContainer", chartData, patternPoints);

        try
        {
            ticks = await TickService.GetTicksAsync(windowStart, windowEnd);
            await JS.InvokeVoidAsync("renderTickChart", ticks.Select(t => new
            {

                time = t.LocalTime.ToString("HH:mm:ss"),
 //               time = t.Time.ToLocalTime().ToString("HH:mm:ss"),
                mid = (double)t.Mid
            }));
        }
        catch (Exception)
        {
            // Handle exceptions as needed
        }

        StateHasChanged(); // Ensure UI updates for indicator
    }

    private async Task ZoomIn()
    {
        if (isUpdating) return;
        isUpdating = true;

        var range = windowEnd - windowStart;
        var mid = windowStart + TimeSpan.FromTicks(range.Ticks / 2);
        var newRange = TimeSpan.FromTicks(range.Ticks / 2);

        windowStart = mid - TimeSpan.FromTicks(newRange.Ticks / 2);
        windowEnd = mid + TimeSpan.FromTicks(newRange.Ticks / 2);

        await RefreshChartAsync();
        StateHasChanged();
        isUpdating = false;
    }

    private async Task ZoomOut()
    {
        if (isUpdating) return;
        isUpdating = true;

        var range = windowEnd - windowStart;
        var mid = windowStart + TimeSpan.FromTicks(range.Ticks / 2);
        var newRange = TimeSpan.FromTicks(range.Ticks * 2);

        windowStart = mid - TimeSpan.FromTicks(newRange.Ticks / 2);
        windowEnd = mid + TimeSpan.FromTicks(newRange.Ticks / 2);

        await RefreshChartAsync();
        StateHasChanged();
        isUpdating = false;
    }

    private async Task PanLeft()
    {
        if (isUpdating) return;
        isUpdating = true;

        var range = windowEnd - windowStart;
        var shift = TimeSpan.FromTicks(range.Ticks / 4);

        windowStart = windowStart - shift;
        windowEnd = windowStart + range;

        await RefreshChartAsync();
        StateHasChanged();
        isUpdating = false;
    }

    private async Task PanRight()
    {
        if (isUpdating) return;
        isUpdating = true;

        var range = windowEnd - windowStart;
        var shift = TimeSpan.FromTicks(range.Ticks / 4);

        windowStart = windowStart + shift;
        windowEnd = windowStart + range;

        await RefreshChartAsync();
        StateHasChanged();
        isUpdating = false;
    }

    private async Task ResetZoom()
    {
        if (isUpdating) return;
        isUpdating = true;

        windowStart = initialWindowStart;
        windowEnd = initialWindowEnd;

        await RefreshChartAsync();
        StateHasChanged();
        isUpdating = false;
    }

    private long DateTimeToUnix(DateTime dt) =>
        new DateTimeOffset(dt).ToUnixTimeMilliseconds();

    public void Dispose()
    {
        refreshTimer?.Dispose();
    }

    private bool IsFollowingLatest =>
        (DateTime.UtcNow.ToLocalTime() - windowEnd).TotalMinutes< 3;
}



